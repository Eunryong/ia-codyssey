컨테이너와 가상 머신은 리소스 격리 및 할당 측면에서 유사한 이점을 제공하지만, 컨테이너는 하드웨어 대신 운영 체제를 가상화한다는 점에서 기능이 다릅니다. 컨테이너는 이동성과 효율성이 더 뛰어납니다.

컨테이너
컨테이너는 앱 계층에서 코드와 종속성을 함께 패키징하는 추상화입니다. 여러 컨테이너가 동일한 머신에서 실행될 수 있으며, 다른 컨테이너와 OS 커널을 공유하여 각 컨테이너가 사용자 공간에서 격리된 프로세스로 실행됩니다. 컨테이너는 VM보다 공간을 적게 차지하며(컨테이너 이미지는 일반적으로 수십 MB 크기), 더 많은 애플리케이션을 처리할 수 있고 더 적은 VM과 운영 체제를 필요로 합니다.

가상 머신
가상 머신(VM)은 물리적 하드웨어를 추상화하여 하나의 서버를 여러 대의 서버로 변환하는 것입니다. 하이퍼바이저를 사용하면 단일 머신에서 여러 VM을 실행할 수 있습니다. 각 VM에는 운영 체제, 애플리케이션, 필수 바이너리 및 라이브러리의 전체 복사본이 포함되어 수십 GB의 용량을 차지합니다. 또한 VM은 부팅 속도가 느릴 수 있습니다.


---

Docker 객체
Docker를 사용하면 이미지, 컨테이너, 네트워크, 볼륨, 플러그인 및 기타 객체를 생성하고 사용할 수 있습니다. 이 섹션에서는 이러한 객체 중 일부에 대한 간략한 개요를 제공합니다.

이미지
이미지는 Docker 컨테이너 생성 지침이 포함된 읽기 전용 템플릿입니다. 이미지는 다른 이미지를 기반으로 하며, 추가적인 사용자 정의가 필요한 경우가 많습니다. 예를 들어, 이미지를 기반으로 ubuntu Apache 웹 서버와 애플리케이션, 그리고 애플리케이션 실행에 필요한 구성 세부 정보가 포함된 이미지를 빌드할 수 있습니다.

이미지를 직접 만들거나, 다른 사람이 만들어 레지스트리에 게시한 이미지만 사용할 수도 있습니다. 이미지를 직접 빌드하려면 이미지를 생성하고 실행하는 데 필요한 단계를 정의하는 간단한 구문을 포함하는 Dockerfile을 만듭니다. Dockerfile의 각 명령은 이미지에 레이어를 생성합니다. Dockerfile을 변경하고 이미지를 다시 빌드하면 변경된 레이어만 다시 빌드됩니다. 이것이 다른 가상화 기술에 비해 이미지를 가볍고, 작고, 빠르게 만드는 이유 중 하나입니다.

컨테이너
컨테이너는 실행 가능한 이미지 인스턴스입니다. Docker API 또는 CLI를 사용하여 컨테이너를 생성, 시작, 중지, 이동 또는 삭제할 수 있습니다. 컨테이너를 하나 이상의 네트워크에 연결하거나, 스토리지를 연결하거나, 현재 상태를 기반으로 새 이미지를 생성할 수도 있습니다.

기본적으로 컨테이너는 다른 컨테이너 및 호스트 머신으로부터 비교적 잘 격리됩니다. 컨테이너의 네트워크, 스토리지 또는 기타 기본 하위 시스템이 다른 컨테이너 또는 호스트 머신으로부터 얼마나 격리되는지 제어할 수 있습니다.

컨테이너는 이미지뿐만 아니라 컨테이너를 생성하거나 시작할 때 제공하는 구성 옵션에 의해 정의됩니다. 컨테이너가 제거되면 영구 저장소에 저장되지 않은 상태 변경 사항은 모두 사라집니다.


도커 아키텍처
Docker는 클라이언트-서버 아키텍처를 사용합니다. Docker 클라이언트는 Docker 데몬과 통신하며, 데몬은 Docker 컨테이너를 빌드, 실행 및 배포하는 중요한 작업을 수행합니다. Docker 클라이언트와 데몬은 동일한 시스템에서 실행될 수도 있고, Docker 클라이언트를 원격 Docker 데몬에 연결할 수도 있습니다. Docker 클라이언트와 데몬은 REST API, UNIX 소켓 또는 네트워크 인터페이스를 사용하여 통신합니다. 또 다른 Docker 클라이언트인 Docker Compose를 사용하면 컨테이너 집합으로 구성된 애플리케이션을 작업할 수 있습니다.


1. 컨테이너 런타임의 정의
**컨테이너 런타임(Container Runtime)**은
컨테이너 이미지를 기반으로 컨테이너를 **생성(Create), 실행(Start), 정지(Stop), 삭제(Delete)**하는 소프트웨어입니다.
운영체제의 namespace와 cgroups 기술을 사용하여 프로세스를 격리하고 자원을 관리하며,
**OCI(Open Container Initiative)**에서 정의한 컨테이너 실행 표준(Runtime Spec)을 따릅니다.

2. 컨테이너 런타임의 역할
컨테이너 이미지에서 애플리케이션 실행 환경을 생성

컨테이너의 네트워크, 파일시스템, 프로세스, 리소스(CPU, 메모리 등) 관리

컨테이너 라이프사이클 관리(생성 → 실행 → 정지 → 삭제)


---

컨테이너 런타임 3가지

1. containerd
정의: Docker에서 분리되어 **CNCF(Cloud Native Computing Foundation)**에 기부된 고수준(High-level) 컨테이너 런타임

주요 기능:

컨테이너 라이프사이클 관리 (생성, 시작, 정지, 삭제)

이미지 전송(Pull/Push), 저장소 관리

네트워크 및 볼륨 관리

특징:

Docker Engine 내부에서도 사용

Kubernetes의 기본 런타임(CRI(Container Runtime Interface) 지원)

기반 기술: 저수준 런타임인 runc를 호출해 컨테이너를 실제 실행

2. CRI-O
정의: Kubernetes 전용으로 설계된 경량화 컨테이너 런타임

주요 기능:

Kubernetes의 **CRI(Container Runtime Interface)**를 직접 구현

오직 OCI(Open Container Initiative) 규격 이미지만 지원

특징:

Kubernetes와의 호환성을 위해 만들어져 불필요한 Docker 의존성 제거

단순성과 보안성이 강조됨 (컨테이너 실행에 꼭 필요한 기능만 제공)

기반 기술: 컨테이너 실행 시 내부적으로 runc를 호출

3. runc
정의: 저수준(Low-level) 컨테이너 런타임

주요 기능:

실제 컨테이너 프로세스를 리눅스에서 실행 (namespace, cgroups 설정)

OCI Runtime Spec의 참조 구현(reference implementation)

특징:

단독 사용보다는 containerd나 CRI-O 같은 고수준 런타임에 의해 호출되는 형태가 일반적

Docker와 Kubernetes 모두 runc를 기반으로 컨테이너를 실행

---

도커 이미지 레이어

1. 도커 이미지의 레이어란?
**도커 이미지(Docker Image)**는 여러 개의 읽기 전용(Read-only) 레이어로 구성됩니다.
각 레이어는 Dockerfile의 명령(FROM, RUN, COPY, ADD 등)을 실행할 때마다 생성되며,
변경된 부분만 새로운 레이어로 추가되어 효율적인 저장과 배포가 가능합니다.

2. 도커 이미지 레이어의 특징
불변성(Read-only)

이미지 레이어는 수정되지 않고 그대로 유지됩니다.

변경 사항이 발생하면 기존 레이어 위에 새로운 레이어가 추가됩니다.

캐싱(Cache) 기능

동일한 레이어를 여러 컨테이너나 이미지에서 재사용할 수 있어 빌드 속도가 빨라집니다.

최종 컨테이너 레이어

컨테이너 실행 시 이미지 위에 읽기/쓰기 가능한 컨테이너 레이어가 추가됩니다.

컨테이너에서 발생한 변경 사항(파일 생성, 로그 등)은 이 레이어에 저장됩니다.
